package au.com.codeka.warworlds.server.data;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.sql.Types;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Locale;
import java.util.TimeZone;

import org.joda.time.ReadableInstant;

import au.com.codeka.common.Log;

/**
 * This is a wrapper around a \c PreparedStatement, for ease-of-use.
 */
public class SqlStmt implements AutoCloseable {
  private static final Log log = new Log("SqlStmt");
  private static Calendar sUTC;

  private static boolean DBG = false;

  static {
    sUTC = Calendar.getInstance(TimeZone.getTimeZone("UTC"));
  }

  private Connection conn;
  private PreparedStatement stmt;
  private boolean autoCloseConnection;
  private String sql;
  private ArrayList<Object> parameters;
  private ArrayList<SqlResult> results;
  private boolean wasStatementLogged;

  public SqlStmt(Connection conn, String sql, PreparedStatement stmt,
                 boolean autoCloseConnection) {
    this.conn = conn;
    this.stmt = stmt;
    this.sql = sql;
    this.autoCloseConnection = autoCloseConnection;
    parameters = new ArrayList<>();
    results = new ArrayList<>();
    wasStatementLogged = false;
  }

  public void setInt(int position, int value) throws SQLException {
    wasStatementLogged = false;
    stmt.setInt(position, value);
    saveParameter(position, value);
  }

  public void setInt(int position, Integer value) throws SQLException {
    wasStatementLogged = false;
    if (value == null) {
      setNull(position);
    } else {
      stmt.setInt(position, value);
      saveParameter(position, value);
    }
  }

  public void setLong(int position, long value) throws SQLException {
    wasStatementLogged = false;
    stmt.setLong(position, value);
    saveParameter(position, value);
  }

  public void setLong(int position, Long value) throws SQLException {
    wasStatementLogged = false;
    if (value == null) {
      setNull(position);
    } else {
      stmt.setLong(position, value);
      saveParameter(position, value);
    }
  }

  public void setDouble(int position, double value) throws SQLException {
    wasStatementLogged = false;
    stmt.setDouble(position, value);
    saveParameter(position, value);
  }

  public void setDouble(int position, Double value) throws SQLException {
    wasStatementLogged = false;
    if (value == null) {
      setNull(position);
    } else {
      stmt.setDouble(position, value);
      saveParameter(position, value);
    }
  }

  public void setString(int position, String value) throws SQLException {
    wasStatementLogged = false;
    if (value == null) {
      setNull(position);
    } else {
      stmt.setString(position, value);
      saveParameter(position, value);
    }
  }

  public void setDateTime(int position, ReadableInstant value) throws SQLException {
    wasStatementLogged = false;
    if (value == null) {
      setNull(position);
    } else {
      stmt.setTimestamp(position, new Timestamp(value.getMillis()), sUTC);
      saveParameter(position, value);
    }
  }

  public void setBytes(int position, byte[] bytes) throws SQLException {
    wasStatementLogged = false;
    if (bytes == null) {
      setNull(position);
    } else {
      stmt.setBytes(position, bytes);
      saveParameter(position, String.format(Locale.US, "<BLOB> %d bytes", bytes.length));
    }
  }

  public void setNull(int position) throws SQLException {
    wasStatementLogged = false;
    stmt.setNull(position, Types.NULL);
    saveParameter(position, "<NULL>");
  }

  private void saveParameter(int position, Object value) {
    wasStatementLogged = false;
    int index = position - 1;
    while (parameters.size() < position) {
      parameters.add(null);
    }
    parameters.set(index, value);
  }

  /**
   * Execute an 'update' query. That is, anything but "SELECT".
   */
  public int update() throws SQLException {
    logStatement();
    return stmt.executeUpdate();
  }

  public int getAutoGeneratedID() throws SQLException {
    ResultSet rs = null;
    try {
      rs = stmt.getGeneratedKeys();
      if (rs.next()) {
        return rs.getInt(1);
      }
    } finally {
      if (rs != null) {
        rs.close();
      }
    }

    throw new SQLException("No auto-generated ID available.");
  }

  @SuppressWarnings("unchecked")
  public <T> T selectFirstValue(Class<T> type) throws SQLException {
    logStatement();

    ResultSet rs = null;
    try {
      rs = stmt.executeQuery();
      if (rs.next()) {
        return (T) rs.getObject(1);
      }
      return null;
    } finally {
      if (rs != null) rs.close();
    }
  }

  public SqlResult select() throws SQLException {
    logStatement();

    SqlResult result = new SqlResult(stmt.executeQuery());
    results.add(result);
    return result;
  }

  /**
   * Wrapper for executing a single "UPDATE ; SELECT" combo, which is somewhat common.
   * <p>
   * Returns the {@link ResultSet} from the SELECT statement.
   */
  public SqlResult updateAndSelect() throws SQLException {
    logStatement();
    stmt.execute();

    SqlResult res = new SqlResult(stmt.getResultSet());
    results.add(res);
    return res;
  }

  private void logStatement() {
    if (wasStatementLogged || !DBG) {
      return;
    }
    wasStatementLogged = true;

    if (log.isDebugEnabled()) {
      StringBuffer sb = new StringBuffer();
      sb.append(sql);
      sb.append(System.lineSeparator());
      for (Object obj : parameters) {
        sb.append(String.format("? = %s", obj.toString()));
        sb.append(System.lineSeparator());
      }
      log.debug(sb.toString());
    }
  }

  @Override
  public void close() throws Exception {
    logStatement();

    for (SqlResult res : results) {
      res.close();
    }
    stmt.close();
    if (autoCloseConnection) {
      conn.close();
    }
  }
}
